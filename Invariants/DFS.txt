Baseline://////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

useful: 8
trivial: 1
sometimes useful: 10

assert(vertices > 0);                        // createGraph – graph must have at least one vertex

assert(src  >= 0 && src  < graph->vertices); // addEdge – source index within bounds
assert(dest >= 0 && dest < graph->vertices); // addEdge – destination index within bounds

assert(vertex >= 0 && vertex < graph->vertices);          // DFS – current vertex within bounds
assert(adjacentVertex >= 0 && adjacentVertex < graph->vertices); // DFS – adjacent vertex within bounds

assert(orderSize >= 0 && orderSize <= graph->vertices);   // DFSTraversal – traversal list size valid
assert(order[i]  >= 0 && order[i]  < graph->vertices);    // DFSTraversal – each listed vertex valid

assert(orderSize == vertices);               // main – traversal order covers all vertices


COT: ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

useful: 4
trivial: 2
sometimes useful: 1

Return Useful invariants here

for (int x = 0; x < i - 1; ++x) assert(arr[x] <= arr[x + 1]); // before each outer-loop pass, arr[0..i-1] is already sorted

for (int x = 0; x < i; ++x) assert(arr[x] <= arr[x + 1]); // after inserting key, arr[0..i] is sorted

for (int x = 0; x < n - 1; ++x) assert(arr[x] <= arr[x + 1]); // inside insertionSort, verifies the whole array is sorted on exit

for (int i = 0; i < n - 1; ++i) assert(arr[i] <= arr[i + 1]); // in main, post-condition that the returned array is fully sorted


Role://///////////////////////////////////////////////////////////////


useful: 3
trivial: 0
sometimes useful: 1

Return Useful invariants here

assert(is_sorted(arr, 0, i - 1)); // sub-array sorted before processing arr[i]

assert(is_sorted(arr, 0, i)); // sub-array sorted after inserting key

assert(is_sorted(arr, 0, n - 1)); // whole array sorted at function exit


