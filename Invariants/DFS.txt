Baseline://////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

useful: 8
trivial: 1
sometimes useful: 10

assert(vertices > 0);                        // createGraph – graph must have at least one vertex

assert(src  >= 0 && src  < graph->vertices); // addEdge – source index within bounds
assert(dest >= 0 && dest < graph->vertices); // addEdge – destination index within bounds

assert(vertex >= 0 && vertex < graph->vertices);          // DFS – current vertex within bounds
assert(adjacentVertex >= 0 && adjacentVertex < graph->vertices); // DFS – adjacent vertex within bounds

assert(orderSize >= 0 && orderSize <= graph->vertices);   // DFSTraversal – traversal list size valid
assert(order[i]  >= 0 && order[i]  < graph->vertices);    // DFSTraversal – each listed vertex valid

assert(orderSize == vertices);               // main – traversal order covers all vertices


COT: ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

useful: 8
trivial: 5
sometimes useful: 14

assert(vertices > 0);                        /* createGraph – graph must have ≥ 1 vertex            */

assert(src  >= 0 && src  < graph->vertices); /* addEdge – source index within bounds                */
assert(dest >= 0 && dest < graph->vertices); /* addEdge – destination index within bounds           */

assert(vertex >= 0 && vertex < graph->vertices);          /* DFS – vertex index within bounds      */
assert(!visited[vertex]);                                   /* DFS – pre-condition: vertex unvisited */

assert(adjacentVertex >= 0 && adjacentVertex < graph->vertices); /* DFS – adjacent within bounds  */

assert(order[i] >= 0 && order[i] < graph->vertices);      /* DFSTraversal – every vertex index valid */

assert(orderSize == vertices);               /* main – traversal order covers all vertices          */


Role://///////////////////////////////////////////////////////////////


useful: 3
trivial: 0
sometimes useful: 1

Return Useful invariants here

assert(is_sorted(arr, 0, i - 1)); // sub-array sorted before processing arr[i]

assert(is_sorted(arr, 0, i)); // sub-array sorted after inserting key

assert(is_sorted(arr, 0, n - 1)); // whole array sorted at function exit


