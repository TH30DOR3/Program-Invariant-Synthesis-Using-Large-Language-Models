Baseline://////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

useful: 2
trivial: 2
sometimes useful: 1

Return Useful invariants here

assert(isSorted(arr, 0, i - 1)); // at the start of each outer-loop pass, guarantees the induction hypothesis that arr[0..i-1] is sorted

assert(isSorted(arr, 0, i)); // after inserting key, confirms that the prefix arr[0..i] is now sorted, preserving correctness

COT: ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

useful: 4
trivial: 2
sometimes useful: 1

Return Useful invariants here

for (int x = 0; x < i - 1; ++x) assert(arr[x] <= arr[x + 1]); // before each outer-loop pass, arr[0..i-1] is already sorted

for (int x = 0; x < i; ++x) assert(arr[x] <= arr[x + 1]); // after inserting key, arr[0..i] is sorted

for (int x = 0; x < n - 1; ++x) assert(arr[x] <= arr[x + 1]); // inside insertionSort, verifies the whole array is sorted on exit

for (int i = 0; i < n - 1; ++i) assert(arr[i] <= arr[i + 1]); // in main, post-condition that the returned array is fully sorted


Role://///////////////////////////////////////////////////////////////


useful: 3
trivial: 0
sometimes useful: 1

Return Useful invariants here

assert(is_sorted(arr, 0, i - 1)); // sub-array sorted before processing arr[i]

assert(is_sorted(arr, 0, i)); // sub-array sorted after inserting key

assert(is_sorted(arr, 0, n - 1)); // whole array sorted at function exit


